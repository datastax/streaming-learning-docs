= Get started with the {starlight-rabbitmq} extension
:navtitle: {starlight-rabbitmq}
:description: Use the {starlight-rabbitmq} extension with {pulsar-reg}.

The https://github.com/datastax/starlight-for-rabbitmq[{starlight-rabbitmq} extension] enables https://www.rabbitmq.com/[RabbitMQ] protocol support for https://pulsar.apache.org/[{pulsar-reg}] by introducing a RabbitMQ protocol handler on {pulsar-short} brokers or {pulsar-short} proxies.

The extension acts as a proxy between your https://www.rabbitmq.com/[RabbitMQ] application and https://pulsar.apache.org/[{pulsar-reg}] cluster.
It implements the AMQP 0.9.1 protocol used by RabbitMQ clients and translates AMQP frames and concepts to {pulsar-short} concepts.

By adding the Starlight for RabbitMQ protocol handler to your {pulsar-short} cluster, you can migrate your existing RabbitMQ applications and services to {pulsar-short} without modifying the code.

//Move image to the Starlight for RabbitMQ main index page
image:s4r-architecture.png[{starlight-rabbitmq} Architecture]

[#establish-the-rabbitmq-protocol-handler]
== Establish the RabbitMQ protocol handler

Before a RabbitMQ client can interact with your {pulsar-short} cluster, you need the {starlight-rabbitmq} protocol handler installed in the cluster.

[tabs]
======
Astra Streaming::
+
--
These steps explain how to enable the {starlight-rabbitmq} protocol handler in an Astra Streaming {pulsar-short} cluster, and then get the connection details for your RabbitMQ client:

. In the {astra-ui-link} header, click icon:grip[name="Applications"], and then select *Streaming*.

. xref:astra-streaming:getting-started:index.adoc[Create a tenant] or click the name of an existing tenant.

. Go to your tenant's **Connect** tab, select **RabbitMQ**, and then click **Enable RabbitMQ**.

. Review the information about the {starlight-rabbitmq} extension, and then click **Enable RabbitMQ** to confirm that you want to enable this extension on your tenant.
+
[IMPORTANT]
====
This action creates a configuration file and a `rabbitmq` namespace in your Astra Streaming tenant automatically.

The `rabbitmq` namespace is required for the {starlight-rabbitmq} extension to function properly.
It is a permanent namespace that cannot be removed except by deleting the entire tenant and all of its data.
====

. Save the RabbitMQ connection details to a file named `rabbitmq.conf`.
The actual values depend on your Astra Streaming tenant's configuration and cloud provider.
+
.rabbitmq.conf
[source,conf,subs="+quotes,+attributes"]
----
username: **TENANT_NAME**
password: {asterisk}{asterisk}{asterisk}{asterisk}{asterisk}{asterisk}
host: rabbitmq-**PROVIDER**-**REGION**.streaming.datastax.com
port: 5671
virtual_host: **TENANT_NAME**/rabbitmq
ampq_URI: {asterisk}{asterisk}{asterisk}{asterisk}{asterisk}{asterisk}@rabbitmq-**PROVIDER**-**REGION**.streaming.datastax.com:5671/**TENANT_NAME**/rabbitmq
----
+
[TIP]
====
In Astra Streaming, if you click icon:download[name="Download"] or icon:clipboard[name="Copy"], then a {pulsar-short} token is included in the `password` field automatically.
You can also generate a token on your tenant's **Settings** tab.
====
+
Continue to the next section to learn how to use these connection details in a RabbitMQ client script.

--

Luna Streaming::
+
--
The {starlight-rabbitmq} extension is included in the `luna-streaming-all` image used to deploy a Luna cluster.
The Luna Helm chart simplifies deployment of the the RabbitMQ extension.

The following steps explain how to deploy a Luna Streaming Helm chart to create a simple {pulsar-short} cluster with the {starlight-rabbitmq} extension ready for use:

. Make sure you meet the following prerequisites:
+
* Install https://helm.sh/docs/intro/install/[Helm 3 CLI] version 3.8.0 or later.
* Install https://kubernetes.io/docs/tasks/tools/[kubectl CLI] version 1.23.4 or later.
* Have access to a Kubernetes cluster with permission to create a namespace, deployments, and pods.

. Add the {company} Helm chart repo to your Helm store:
+
[source,shell]
----
helm repo add datastax-pulsar https://datastax.github.io/pulsar-helm-chart
----

. Install the Helm chart using a minimal values file.
The following command creates a Helm release named `my-pulsar-cluster` using the {company} Luna Helm chart within a Kubernetes namespace named `datastax-pulsar`.
This minimal configuration creates only the essential components and has no ingress or load balanced services.
+
[source,shell]
----
VALUES_URL="https://raw.githubusercontent.com/datastaxdevs/luna-streaming-examples/main/starlight-for-rabbitmq/values.yaml"
helm install \
  --namespace datastax-pulsar \
  --create-namespace \
  --values $VALUES_URL \
  --version 3.0.4 \
  my-pulsar-cluster \
  datastax-pulsar/pulsar
----

. Wait for the broker pod to reach a running state.
It might restart a few times while the components start up.
+
[source,shell]
----
kubectl -n datastax-pulsar wait --for=condition=Ready pod/pulsar-broker-0 --timeout=120s
----

. Enable port forwarding for the {pulsar-short} Admin and {starlight-rabbitmq} services that are running on the Kubernetes cluster:
+
.. In a new terminal, port forward the {pulsar-short} Admin service:
+
[source,shell]
----
kubectl port-forward -n datastax-pulsar service/pulsar-broker 8080:8080
----

.. In a separate terminal window, port forward the {starlight-rabbitmq} service:
+
[source,shell]
----
kubectl port-forward -n datastax-pulsar service/pulsar-proxy 5672:5672
----

+
[TIP]
====
You don't need to open the {pulsar-short} binary port to accept new messages when using {starlight-rabbitmq}.
This is because RabbitMQ clients communicate using the AMQP protocol over the RabbitMQ port (5672).
====
The Luna Helm chart deployed Starlight for RabbitMQ on the {pulsar-short} proxy and opened the correct port.
The forwarded ports allow you to access {pulsar-short} and {starlight-rabbitmq} services when running RabbitMQ client scripts and using CLI tools locally.
Your applications can now communicate with {pulsar-short} as if it were a real RabbitMQ host, as explained in the next section.

--

Self-managed::
+
--
To use {starlight-rabbitmq} with self-managed or standalone {pulsar-short} clusters, see xref:starlight-for-rabbitmq:installation:getting-started.adoc[].
--
======

== Produce and consume messages with {starlight-rabbitmq}

This section explains how to use your Pulsar tenant's connection details with a RabbitMQ client to produce and consume messages with {starlight-rabbitmq}.

{starlight-rabbitmq} supports many different use cases.
With a {pulsar-short} cluster between publishers and consumers, you can change the type of publisher and consumer to fit your needs.

The following examples use Python and Java.
The Java example uses Maven, but you can also use Gradle.
For complete source code examples and examples for other languages, see the https://github.com/datastax/astra-streaming-examples[{company} streaming examples repository].
These examples are written for Astra Streaming but they can be adapted for Luna Streaming or self-managed {pulsar-short} clusters by replacing the connection details with those for your cluster.

[tabs]
======
Astra Streaming::
+
--
[tabs]
====
Python client::
+
The following example uses a Python script to create a connection between RabbitMQ and your Astra Streaming tenant.
It also establishes a message queue named `queuename`, prints ten messages, and then closes the connection.
+
. Enable {starlight-rabbitmq} and get the `rabbitmq.conf` connection details, as explained in <<establish-the-rabbitmq-protocol-handler>>.
+
. Create a `connect-test.py` file containing the following code, and then replace the placeholders with the values from your `rabbitmq.conf` file:
+
.connect-test.py
[source,python,subs="+quotes"]
----
import ssl
import pika

virtual_host = "**VIRTUAL_HOST**"
token = "**PASSWORD**"

context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
context.verify_mode = ssl.CERT_NONE
context.check_hostname = False
context.load_default_certs()
ssl_options = pika.SSLOptions(context)

connection = pika.BlockingConnection(pika.ConnectionParameters(
    virtual_host=virtual_host,
    host="**HOST**",
    ssl_options=ssl_options,
    port=**PORT**,
    credentials=pika.PlainCredentials("", token)))
print("connection success")

channel = connection.channel()
print("started a channel")

channel.queue_declare(queue='queuename')

for x in range(10):
    channel.basic_publish(exchange='',
                      routing_key='routingkey',
                      body='message body goes here')
    print(" sent one")

connection.close()
----
+
. Optional: Change the values for `queue`, `routing_key`, and `body`.
`queuename` and `routingkey` become the names of {pulsar-short} topics in your Astra Streaming tenant.
The `body` is the content of each message that is sent.
+
. Save and run the `connect-test.py` script:
+
[source,shell]
----
python3 connect-test.py
----
+
. Make sure the output shows that the connection was successful and ten messages were sent:
+
[source,console]
----
connection success
started a channel
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
----
+
. In Astra Streaming, go to your tenant's **Namespaces and Topics** tab to inspect the activity in the `rabbitmq` namespace.
+
If you everything was configured correctly, then the `rabbitmq` namespace should have topics named `amq.default.__queuename` and `amq.default_routingkey` that were created by the Python script.
Additionally, the namespace's metrics should reflect that at least 10 messages were published and consumed by your Astra Streaming {pulsar-short} topics.

Java client::
+
The following example uses a Java program to create a connection between RabbitMQ and your Astra Streaming tenant, and then it establishes a message queue and sends a message.
+
. Enable {starlight-rabbitmq} and get the `rabbitmq.conf` connection details, as explained in <<establish-the-rabbitmq-protocol-handler>>.
+
. Create a new Maven project:
+
[source,shell]
----
mvn archetype:generate \
    -DgroupId=org.example \
    -DartifactId=StarlightForRabbitMqClient \
    -DarchetypeArtifactId=maven-archetype-quickstart \
    -DinteractiveMode=false
----
+
. Change to the new project directory:
+
[source,shell]
----
cd StarlightForRabbitMqClient
----
+
. Open the new project in your IDE, and then add the RabbitMQ client dependency to `pom.xml`:
+
.pom.xml
[source,xml]
----
<dependency>
  <groupId>com.rabbitmq</groupId>
  <artifactId>amqp-client</artifactId>
  <version>5.16.0</version>
</dependency>
----
+
. Open the `App.java` file at `src/main/java/org/example/App.java`, and then delete any preeixsting code in this file.
In the next steps, you will add code to this file to create a complete program that produces and consumes messages.
+
. Paste the following code in the file, and then replace the placeholders with the values from your `rabbitmq.conf` file.
Your editor will report errors because this isn't a complete program yet.
+
.App.java
[source,java,subs="+quotes"]
----
package org.example;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.TimeoutException;

public class App {
  private static final String username = "";
  private static final String password = "**PASSWORD**";
  private static final String host = "**HOST**";
  private static final int port = 5671;
  private static final String virtual_host = "**VIRTUAL_HOST**";
  private static final String queueName = "queuename";
  private static final String amqp_URI = String.format("amqps://%s:%s@%s:%d/%s", username, password, host, port, virtual_host.replace("/","%2f"));

  public static void main(String[] args) throws IOException, TimeoutException, URISyntaxException, NoSuchAlgorithmException, KeyManagementException, InterruptedException {
----
+
. Optional: Replace `queuename` with another name for the queue that publishes and consumes messages.
This name is also used as the corresponding topic name in Astra Streaming.
If the topic doesn't exist, it is created automatically when the producer sends the first message.
+
. Add the following code to create a connection, channel, and queue that is used by both the producer and consumer:
+
.App.java
[source,java]
----
    ConnectionFactory factory = new ConnectionFactory();
    factory.setUri(amqp_URI);

    /*
    You could also set each value individually
      factory.setHost(host);
      factory.setPort(port);
      factory.setUsername(username);
      factory.setPassword(password);
      factory.setVirtualHost(virtual_host);
      factory.useSslProtocol();
     */

    Connection connection = factory.newConnection();
    Channel channel = connection.createChannel();

    channel.queueDeclare(queueName, false, false, false, null);
----
+
. Add the producer code, which is a simple flow that sends a single message and awaits acknowledgment:
+
.App.java
[source,java]
----
    String publishMessage = "Hello World!";
    channel.basicPublish("", queueName, null, publishMessage.getBytes());
    System.out.println(" Sent '" + publishMessage + "'");
----
+
. Add the consumer code, which creates a basic consumer with callback on message receipt.
Because the consumer isn't a blocking thread, the `sleep` allows time for messages to be received and processed.
+
.App.java
[source,java]
----
    DeliverCallback deliverCallback = (consumerTag, delivery) -> {
      String consumeMessage = new String(delivery.getBody(), StandardCharsets.UTF_8);
      System.out.println(" Received '" + consumeMessage + "'");
    };

    channel.basicConsume(queueName, true, deliverCallback, consumerTag -> { });

    Thread.sleep(4000); // wait a bit for messages to be received

    channel.close();
    connection.close();
  }
}
----
+
. Save `App.java`, and then build and run the JAR file for the complete program:
+
[source,shell]
----
mvn clean package assembly:single
java -jar target/StarlightForRabbitMqClient-1.0-SNAPSHOT-jar-with-dependencies.jar
----
+
. Make sure the result shows that a message was sent and received:
+
[source,shell]
----
Sent 'Hello World!'
Received 'Hello World!'
----
+
. In Astra Streaming, go to your tenant's **Namespaces and Topics** tab to inspect the activity in the `rabbitmq` namespace.
+
If you everything was configured correctly, then the `rabbitmq` namespace should have a topic named `amq.default.__queuename` that was created by the Java program.
Additionally, the namespace's metrics should reflect that at least one message was published and consumed by your Astra Streaming {pulsar-short} topic.
====

--

Luna Streaming::
+
--
To use a RabbitMQ client with {starlight-rabbitmq}, you use your Luna Streaming {pulsar-short} tenant as the AMQP listener.
The following examples use a connection on `localhost:5672`.
For other connection methods, see the documentation for your preferred RabbitMQ client library.

[tabs]
====
Python client::
+
The following example uses the Pika RabbitMQ Python library to produce and consume messages from {pulsar-short}.
+
. Save the following Python script to a safe place as `test-queue.py`.
The example script assumes you have opened the `localhost:5672` port, as explained in <<establish-the-rabbitmq-protocol-handler>>.
+
.test-queue.py
[source,python]
----
#!/usr/bin/env python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters(port=5672))
channel = connection.channel()

try:
    channel.queue_declare("test-queue")
    print("created test-queue queue")

    channel.basic_publish(exchange="", routing_key="test-queue", body="test".encode('utf-8'))
    print("published message test")

    _, _, res = channel.basic_get(queue="test-queue", auto_ack=True)
    assert res is not None, "should have received a message"
    print("received message: " + res.decode())

    channel.queue_delete("test-queue")
    print("deleted test-queue queue")

finally:
    connection.close()
----
+
. Optional: Replace `test-queue` with another name for the queue and routing key. These names are also used as the corresponding topic names in your {pulsar-short} tenant. If the topic doesn't exist, it is created automatically when the producer sends the first message.
+
. Save and run the `test-queue.py` script:
+
[source,shell]
----
python ./test-queue.py
----
+
. Make sure the output shows that the queue was created and a message was sent:
+
[source,shell]
----
created test-queue queue
published message test
received message: test
deleted test-queue queue
----
+
. Use the {pulsar} admin CLI or the Luna Streaming {pulsar-short} Admin Console to inspect your tenant's activity.
Make sure the `test-queue` topic was created and a message was published and consumed.

Java client::
+
The following example uses a Java program to create a connection between RabbitMQ and your Luna Streaming {pulsar-short} tenant, and then it establishes a message queue and sends a message.
+
. Create a new Maven project:
+
[source,shell]
----
mvn archetype:generate \
    -DgroupId=org.example \
    -DartifactId=StarlightForRabbitMqClient \
    -DarchetypeArtifactId=maven-archetype-quickstart \
    -DinteractiveMode=false
----
+
. Change to the new project directory:
+
[source,shell]
----
cd StarlightForRabbitMqClient
----
+
. Open the new project in your IDE, and then add the RabbitMQ client dependency to `pom.xml`:
+
.pom.xml
[source,xml]
----
<dependency>
  <groupId>com.rabbitmq</groupId>
  <artifactId>amqp-client</artifactId>
  <version>5.16.0</version>
</dependency>
----
+
. Open the `App.java` file at `src/main/java/org/example/App.java`, and then delete any preeixsting code in this file.
In the next steps, you will add code to this file to create a complete program that produces and consumes messages.
+
. Paste the following code in the file.
This code creates a connection, channel, and queue that is used by both the producer and consumer.
It uses the default connection values to connect on `localhost:5672`, which was port forwarded in <<establish-the-rabbitmq-protocol-handler>>.
Your editor will report errors because this isn't a complete program yet.
+
.App.java
[source,java]
----
package org.example;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.TimeoutException;

public class App {
  private static final String queueName = "queuename";

  public static void main(String[] args) throws IOException, TimeoutException, URISyntaxException, NoSuchAlgorithmException, KeyManagementException, InterruptedException {

    // Use the default values to connect on localhost:5672
    ConnectionFactory factory = new ConnectionFactory();
    factory.setUsername(userName);
    factory.setPassword(password);
    factory.setVirtualHost(virtualHost);
    factory.setHost(hostName);
    factory.setPort(portNumber);

    Connection connection = factory.newConnection();
    Channel channel = connection.createChannel();

    channel.queueDeclare(queueName, false, false, false, null);
----
+
. Optional: Replace `queuename` with another name for the queue that publishes and consumes messages.
This name is also used as the corresponding topic name in Astra Streaming.
If the topic doesn't exist,it is created automatically when the producer sends the first message.
+
. Add the producer code, which is a simple flow that sends a single message and awaits acknowledgment:
+
.App.java
[source,java]
----
    String publishMessage = "Hello World!";
    channel.basicPublish("", queueName, null, publishMessage.getBytes());
    System.out.println(" Sent '" + publishMessage + "'");
----
+
. Add the consumer code, which creates a basic consumer with callback on message receipt.
Because the consumer isn't a blocking thread, the `sleep` allows time for messages to be received and processed.
+
.App.java
[source,java]
----
    DeliverCallback deliverCallback = (consumerTag, delivery) -> {
      String consumeMessage = new String(delivery.getBody(), StandardCharsets.UTF_8);
      System.out.println(" Received '" + consumeMessage + "'");
    };

    channel.basicConsume(queueName, true, deliverCallback, consumerTag -> { });

    Thread.sleep(4000); // wait a bit for messages to be received

    channel.close();
    connection.close();
  }
}
----
+
. Save `App.java`, and then build and run the JAR file for the complete program:
+
[source,shell]
----
mvn clean package assembly:single
java -jar target/StarlightForRabbitMqClient-1.0-SNAPSHOT-jar-with-dependencies.jar
----
+
. Make sure the result shows that a message was sent and received:
+
[source,shell]
----
Sent 'Hello World!'
Received 'Hello World!'
----
+
. Use the {pulsar-short} Admin CLI or the Luna Streaming {pulsar-short} Admin Console to inspect your tenant's activity.
Make sure the `queuename` topic was created and a message was published and consumed.
====

--

Self-managed::
+
--
To use a RabbitMQ client with {starlight-rabbitmq}, you use your {pulsar-short} tenant as the AMQP listener.
You can also connect on `localhost` if you have port forwarded the RabbitMQ port (5672) to your local machine.

For `localhost` examples, see the Luna Streaming tab.
However, the specific connection details and valid connection methods depend on your cluster's configuration.

For more information, see the documentation for your preferred RabbitMQ client library.
--
======

== RabbitMQ exchanges and {pulsar-short} topics

//Move to Publishing messages section under Pulsar protocol handler in Starlight for RabbitMQ docs.

{starlight-rabbitmq} maps RabbitMQ _exchanges_ to {pulsar-short} _topics_, as described in the following table:

[cols=4]
|===
|Exchange |Routing key |{pulsar-short} topic name |Usage example

|`amp.direct`
|Used
|`amq.direct.__{routing key}`
|`channel.basic_publish(exchange='amp.direct'),`

|`amp.default` or empty string
|Used
|`amq.default.__{routing key}`
|`channel.basic_publish(exchange="),`

|`amp.match`
|Not used
|`amp.match`
|`channel.basic_publish(exchange=amp.match),`

|`amp.fanout`
|Not used
|`amp.fanout`
|`channel.basic_publish(exchange='amp.fanout'),`

|`headers`
|Not used
|Header name
|`channel.exchange_declare(exchange='header_logs', exchange_type='headers')`

`channel.basic_publish(exchange='header_logs'),`
|===