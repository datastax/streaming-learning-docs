= Get started with the {starlight-rabbitmq} extension
:navtitle: {starlight-rabbitmq}
:description: Use the {starlight-rabbitmq} extension with {pulsar-reg}.

The https://github.com/datastax/starlight-for-rabbitmq[{starlight-rabbitmq} extension] enables https://www.rabbitmq.com/[RabbitMQ] protocol support for https://pulsar.apache.org/[{pulsar-reg}] by introducing a RabbitMQ protocol handler on {pulsar-short} brokers or {pulsar-short} proxies.

The extension acts as a proxy between your https://www.rabbitmq.com/[RabbitMQ] application and https://pulsar.apache.org/[{pulsar-reg}] cluster.
It implements the AMQP 0.9.1 protocol used by RabbitMQ clients and translates AMQP frames and concepts to {pulsar-short} concepts.

By adding the Starlight for RabbitMQ protocol handler to your {pulsar-short} cluster, you can migrate your existing RabbitMQ applications and services to {pulsar-short} without modifying the code.

For more information about the {starlight-rabbitmq} architecture, see the xref:starlight-for-rabbitmq:ROOT:index.adoc[{starlight-rabbitmq} documentation].

image:s4r-architecture.png[{starlight-rabbitmq} Architecture]

== Establish the RabbitMQ protocol handler

Before you can use a RabbitMQ client to interact with your {pulsar-short} cluster, you need the {starlight-rabbitmq} protocol handler installed in the cluster.
Installation looks a bit different depending on where your {pulsar-short} cluster is running.
Choose the option that best fits your needs.

[tabs]
======
Astra Streaming::
+
--
Get started producing and consuming RabbitMQ messages on an Astra Streaming {pulsar-short} cluster.

. Sign in to your Astra account, go to Astra Streaming, and then xref:astra-streaming:getting-started:index.adoc[create a tenant] or click an existing tenant.

. Go to your tenant's **Connect** tab, select **RabbitMQ**, and then click **Enable RabbitMQ**.

. Review the information about the {starlight-rabbitmq} extension, and then click **Enable RabbitMQ** to confirm that you want to enable this extension on your tenant.
+
[IMPORTANT]
====
This action creates a configuration file and a `rabbitmq` namespace in your Astra Streaming tenant automatically.

The `rabbitmq` namespace is required for the {starlight-rabbitmq} extension to function properly.
It is a permanent namespace that cannot be removed except by deleting the entire tenant and all of its data.
====

. Save the RabbitMQ configuration details to a file named `rabbitmq.conf`.
The actual values depend on your Astra Streaming tenant's configuration and cloud provider.
+
.rabbitmq.conf
[source,conf,subs="+quotes"]
----
username: **TENANT_NAME**
password: token:***
host: rabbitmq-**PROVIDER**-**REGION**.streaming.datastax.com
port: 5671
virtual_host: **PROVIDER**/rabbitmq
----

=== Connect RabbitMQ and {pulsar-short}
//Move to messaging section?
This example uses a Python script to create a connection between RabbitMQ and your {pulsar-short} tenant.
It also establishes a message queue named `queuename`, prints ten messages, and then closes the connection.

. Create a `connect-test.py` file containing the following code:
+
.connect-test.py
[source,python,subs="+quotes"]
----
import ssl
import pika

virtual_host = "**VIRTUAL_HOST**"
token = "**TOKEN**"

context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
context.verify_mode = ssl.CERT_NONE
context.check_hostname = False
context.load_default_certs()
ssl_options = pika.SSLOptions(context)

connection = pika.BlockingConnection(pika.ConnectionParameters(
    virtual_host=virtual_host,
    host="**HOST**",
    ssl_options=ssl_options,
    port=**PORT**,
    credentials=pika.PlainCredentials("", token)))
print("connection success")

channel = connection.channel()
print("started a channel")

channel.queue_declare(queue='queuename')

for x in range(10):
    channel.basic_publish(exchange='',
                      routing_key='routingkey',
                      body='message body goes here')
    print(" sent one")

connection.close()
----
+
Replace the following with values from your `rabbitmq.conf` file:
+
* `**VIRTUAL_HOST**`
* `**TOKEN**` (from the `password` field)
* `**HOST**`
* `**PORT**`

. Save the `connect-test.py` file.

. Run `connect-test.py`:
+
[source,shell]
----
python3 connect-test.py
----

. Make sure the result is similar to the following:
+
[source,console]
----
connection success
started a channel
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
 sent one
----

. Navigate to your `rabbitmq` namespace dashboard in Astra Streaming, and then monitor the namespace's activity.
+
If configured correctly, you should have new topics called `amq.default.__queuename` and `amq.default_routingkey` that were created by the Python script, as well as an increasing amount of traffic and messages.
Your RabbitMQ messages are being published to a {pulsar-short} topic.

=== RabbitMQ exchanges and {pulsar-short} topics

//TBD if duplicated from Starlight docs and/or unique to Astra

{starlight-rabbitmq} maps RabbitMQ _exchanges_ to {pulsar-short} _topics_, as described in the following table:

[cols="1,1,1,1"]
|===
|Exchange |Routing key |{pulsar-short} topic name |Usage example

|`amp.direct`
|used
|`amq.direct.__{routing key}`
|`channel.basic_publish(exchange='amp.direct',`

|`amp.default` or empty string
|used
|`amq.default.__{routing key}`
|`channel.basic_publish(exchange="),`

|`amp.match`
|not used
|`amp.match`
|`channel.basic_publish(exchange=amp.match),`

|`amp.fanout`
|not used
|`amp.fanout`
|`channel.basic_publish(exchange='amp.fanout'),`

|`headers`
|not used
|Name of the header
|`channel.exchange_declare(exchange='header_logs', exchange_type='headers')
channel.basic_publish(exchange='header_logs'),`

|===
--

Luna Streaming::
+
--
The {starlight-rabbitmq} extension is included in the `luna-streaming-all` image used to deploy a Luna cluster.
The Luna Helm chart simplifies deployment of the the RabbitMQ extension.

The following steps explain how to deploy a Luna Streaming Helm chart to create a simple {pulsar-short} cluster with the {starlight-rabbitmq} extension ready for use.

. Make sure you meet the following prerequisites:
+
* https://helm.sh/docs/intro/install/[Helm 3 CLI] (we used version 3.8.0)
* https://kubernetes.io/docs/tasks/tools/[Kubectl CLI] (we used version 1.23.4)
* Python (we used version 3.8.10)
* Enough access to a K8s cluster to create a namespace, deployments, and pods

. Add the {company} Helm chart repo to your Helm store
+
[source,shell]
----
helm repo add datastax-pulsar https://datastax.github.io/pulsar-helm-chart
----

. Install the Helm chart using a minimalist values file.
This command creates a Helm release named `my-pulsar-cluster` using the {company} Luna Helm chart, within the K8s namespace `datastax-pulsar`.
The minimal cluster creates only the essential components and has no ingress or load balanced services.
+
[source,shell]
----
VALUES_URL="https://raw.githubusercontent.com/datastaxdevs/luna-streaming-examples/main/starlight-for-rabbitmq/values.yaml"
helm install \
  --namespace datastax-pulsar \
  --create-namespace \
  --values $VALUES_URL \
  --version 3.0.4 \
  my-pulsar-cluster \
  datastax-pulsar/pulsar
----

. Wait for the broker pod to reach a running state.
It might restart a few times while your components start up.
+
[source,shell]
----
kubectl -n datastax-pulsar wait --for=condition=Ready pod/pulsar-broker-0 --timeout=120s
----

. Forward service ports so you can interact with certain services on the Kubernetes cluster:
+
.. In a new terminal, port forward {pulsar-short}'s admin service:
+
[source,shell]
----
kubectl port-forward -n datastax-pulsar service/pulsar-broker 8080:8080
----

.. In a separate terminal window, port forward the Starlight for RabbitMQ service:
+
[source,shell]
----
kubectl port-forward -n datastax-pulsar service/pulsar-proxy 5672:5672
----

The Luna Helm chart deployed Starlight for RabbitMQ on the {pulsar-short} proxy and opened the correct port.
Your application can now communicate with {pulsar-short} as if it were a real RabbitMQ host.

=== Produce a message with the RabbitMQ Python client
//Move to messaging section
If you hadn't noticed, we never opened the {pulsar-short} binary port to accept new messages.
Only the admin port and the RabbitMQ port are open.
To further demonstrate how native Starlight for RabbitMQ is, we will use the Pika RabbitMQ Python library to produce and consume messages from {pulsar-short}.

Save the following Python script to a safe place as `test-queue.py`.
The script assumes you have opened the localhost:5672 port.

[source,python]
----
#!/usr/bin/env python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters(port=5672))
channel = connection.channel()

try:
    channel.queue_declare("test-queue")
    print("created test-queue queue")

    channel.basic_publish(exchange="", routing_key="test-queue", body="test".encode('utf-8'))
    print("published message test")

    _, _, res = channel.basic_get(queue="test-queue", auto_ack=True)
    assert res is not None, "should have received a message"
    print("received message: " + res.decode())

    channel.queue_delete("test-queue")
    print("deleted test-queue queue")

finally:
    connection.close()
----

Open a terminal and return to the safe place where you saved the Python script.
Run the following command to execute the Python program.

[source,shell]
----
python ./test-queue.py
----

The output should look like the following.

[source,shell]
----
created test-queue queue
published message test
received message: test
deleted test-queue queue
----

--

Self Managed::
+
--
Already have your own {pulsar-short} Cluster? Or maybe you're using a standalone cluster? {starlight-rabbitmq} can easily be a part of that cluster! Follow the "xref:starlight-for-rabbitmq:installation:getting-started.adoc[]" guide.
--
======

== Message with {starlight-rabbitmq}

{starlight-rabbitmq} supports quite a few different use cases.
With a {pulsar-short} cluster between publishers and consumers you can interchange the type of publisher and consumer to fit your needs.

[TIP]
====
The following examples use an Astra Streaming tenant as the AMQP listener.

If you are using Luna Streaming or a self-managed tenant, use the listener URL for your tenant.
====

=== Retrieve RabbitMQ connection properties in Astra Streaming

//Already covered on the Astra tab above. Image isn't needed.
//See if this can be made generic or already provided for both in the Starlight docs

In the Astra Streaming portal "Connect" tab, the "RabbitMQ" area provides important connection information.
You will need this connection information to create a working RabbitMQ client or use the CLI.

image:rabbitmq-client-settings.png[Astra Streaming RabbitMQ settings]

TIP: Click the clipboard icon to copy the RabbitMQ connection values, as well as a working token to paste in code.

=== Produce and consume a message

This example uses Maven for the project structure for a Rabbit MQ Java client.
If you prefer Gradle or another tool, this code should still be a good fit.

For complete source code examples, see the https://github.com/datastax/astra-streaming-examples[Astra Streaming examples repository].

. Create a new Maven project.
+
[source,shell]
----
mvn archetype:generate \
    -DgroupId=org.example \
    -DartifactId=StarlightForRabbitMqClient \
    -DarchetypeArtifactId=maven-archetype-quickstart \
    -DinteractiveMode=false

cd StarlightForRabbitMqClient
----

. Open the new project in your IDE or text editor, and then add the RabbitMQ client dependency to `pom.xml`:
+
[source,xml]
----
<dependency>
  <groupId>com.rabbitmq</groupId>
  <artifactId>amqp-client</artifactId>
  <version>5.16.0</version>
</dependency>
----

. Open the file `src/main/java/org/example/App.java`, and then enter the following code.
If you cloned the example repo, replace the entire contents with the following code.
Your editor will report errors because this isn't a complete program yet.
+
Replace placeholders with the values you previously retrieved from Astra Streaming.
+
[source,java,subs="+quotes"]
----
package org.example;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.TimeoutException;

public class App {
  private static final String username = "";
  private static final String password = "**PULSAR_TOKEN**";
  private static final String host = "**SERVICE_URL**";
  private static final int port = 5671;
  private static final String virtual_host = "**TENANT_NAME**>/rabbitmq"; //The "rabbitmq" namespace should have been created when you enabled S4R
  private static final String queueName = "**TOPIC_NAME**"; //This will get created automatically if it doesn't already exist
  private static final String amqp_URI = String.format("amqps://%s:%s@%s:%d/%s", username, password, host, port, virtual_host.replace("/","%2f"));

  public static void main(String[] args) throws IOException, TimeoutException, URISyntaxException, NoSuchAlgorithmException, KeyManagementException, InterruptedException {
----

. Add the code to create a connection, channel, and queue that will be used by both the producer and consumer:
+
[source,java]
----
    ConnectionFactory factory = new ConnectionFactory();
    factory.setUri(amqp_URI);

    /*
    You could also set each value individually
      factory.setHost(host);
      factory.setPort(port);
      factory.setUsername(username);
      factory.setPassword(password);
      factory.setVirtualHost(virtual_host);
      factory.useSslProtocol();
     */

    Connection connection = factory.newConnection();
    Channel channel = connection.createChannel();

    channel.queueDeclare(queueName, false, false, false, null);
----

. Add the producer code, which is a simple flow that sends a single message and awaits acknowledgment:
+
[source,java]
----
    String publishMessage = "Hello World!";
    channel.basicPublish("", queueName, null, publishMessage.getBytes());
    System.out.println(" Sent '" + publishMessage + "'");
----

. Add the consumer code, which creates a basic consumer with callback on message receipt.
Because the consumer isn't a blocking thread, the `sleep` allows time for messages to be received and processed.
+
[source,java]
----
    DeliverCallback deliverCallback = (consumerTag, delivery) -> {
      String consumeMessage = new String(delivery.getBody(), StandardCharsets.UTF_8);
      System.out.println(" Received '" + consumeMessage + "'");
    };

    channel.basicConsume(queueName, true, deliverCallback, consumerTag -> { });

    Thread.sleep(4000); // wait a bit for messages to be received

    channel.close();
    connection.close();
  }
}
----

. Build and run the JAR file for the complete program:
+
[source,shell]
----
mvn clean package assembly:single
java -jar target/StarlightForRabbitMqClient-1.0-SNAPSHOT-jar-with-dependencies.jar
----
+
.Result
[%collapsible]
====
[source,shell]
----
Sent 'Hello World!'
Received 'Hello World!'
----
====